{"name":"A Dumb Framework","tagline":"A very dumb framework/glue to GLFW/GLEW/SOIL for quick and dirty prototyping.","body":"### Purpose\r\nThere's many good libraries for speeding up your productivity. But sometimes, speeding up is not enough. You're always running out of time. One can always get libraries like GLFW, GLEW, internalisation, font management, texture loading and so on ... But you need to do basic stuff over and over again. Here comes the Dumb Framework. It implements the glue, a slightly higher level of abstraction that combines underneath libraries without cutting you from them.\r\n\r\nWe're talking about ultra-lightweight productions here. It's not about getting a middleware, pushing your assets and publishing a fat prototype. It's about coding a couple of routines, launch your favorite compilers and obtaining a shiny tiny executable.\r\n\r\n### So, how can I use your stuff ?\r\nAssuming you're comfortable with C++, here is the thing: You'll have to create a class that implement a concept compatible with the Dumb Core Application Runner (yeah, that's its name). Then, instanciate a runner and feed it with your fantastic class like this:\r\n\r\n```cpp\r\n#include <DumbFramework/runner.hpp>\r\n\r\nclass MyWrapper {\r\n    DECLARE_WRAPPER_METHODS\r\n    // Do whatever you want ...\r\n    public:\r\n        MyWrapper() {} // You'll need that.\r\n};\r\n\r\n// Implement the wrapper methods. See runner.hpp.\r\n\r\nSIMPLE_APP(MyWrapper)\r\n```\r\n\r\nMore details ?\r\n\r\n```cpp\r\n#include <DumbFramework/runner.hpp>\r\n\r\nclass MyWrapper {\r\n    DECLARE_WRAPPER_METHODS\r\n};\r\n\r\n// Help create the app. This is called BEFORE the window is created.\r\nvoid MyWrapper::init(Dumb::Core::Application::Adviser *adviser) {\r\n    Dumb::Core::Application::Video::Monitor monitor = adviser->getPrimaryMonitor();\r\n    adviser->setMonitor(monitor);\r\n    Dumb::Core::Application::Video::Mode mode = monitor.getCurrentMode();\r\n    adviser->setVideoMode(mode);\r\n    adviser->setTitle(\"Your Favorite Application Title\");\r\n    // The application will be fullscreen on the primary monitor.\r\n    // But there's a way to make windowed apps.\r\n}\r\n\r\n// This is called AFTER window creation/graphic context.\r\nvoid MyWrapper::postInit() {\r\n    // Do whatever that require a graphic context.\r\n}\r\n\r\n// All glory to the render method !\r\nint MyWrapper::render() {\r\n    // Return 0 if you want to quit the application.\r\n    return GL_TRUE;\r\n}\r\n\r\n// This is invoked once the window is closed.\r\nvoid MyWrapper::close() {\r\n    // [...]\r\n}\r\n\r\n// Implements the rest of the wrapping methods (window, mouse and keyboard event handlers).\r\n// [...]\r\n\r\nint main() {\r\n    MyWrapper myWrapper;\r\n    Dumb::Core::Application::Runner runner(&myWrapper);\r\n    int result = runner.start();\r\n    return result;\r\n}\r\n```\r\n\r\n### How does it compile ?\r\n\r\n#### Under Linux\r\n\r\nMake sure to have **cmake** and proceed like this:\r\n\r\n```sh\r\n$ cd DumbFrameworkRoot\r\n$ mkdir build\r\n$ cd build\r\n$ cmake ..\r\n$ make\r\n``` \r\n\r\nThis will produce tons of stuff including the **libDumbFramework.a** static library file. Feel free to modify the CMakeLists.txt file in the root directory to fit your need (and/or to tune it with your favorite options. In my case, I'm very fond of clang++ hence the\r\n```\r\ncmake -DCMAKE_CXX_COMPILER=/usr/bin/clang++ ..\r\n```\r\n).\r\n\r\n#### What you'll need ...\r\n\r\nIn order to compile, the librarie needs the following:\r\n\r\n- cmake >= 2.6\r\n- GLM >= 0.9.5.4\r\n- Latest stb toolbox\r\n- GLEW\r\n- GLFW >= 3\r\n- Box2D (in some cases)\r\n- ICU\r\n\r\n#### Why the hell do I need THAT ?\r\n\r\nThere's some neat stuff already implemented, like OpenGL 4 support, a small sprite engine (the Sprengine), a font renderer (the Dumb Font Engine) and some serious rendering things.\r\n\r\n*SomeRandomGameDev* and *BlockoS/MooZ*\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}